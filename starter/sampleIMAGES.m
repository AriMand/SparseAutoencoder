function patches = sampleIMAGES(patchsize, numpatches)
% sampleIMAGES
% возвращает из 10000 образцов для обучения сети 
load IMAGES;    % Загружаем изображения с диска 
%patchsize = 8;      % мы используем фрагменты 8x8 пикселей  
%numpatches = 1000;  % кол-во образцов для обучения сети
% Инициализируем патчи нулями.
% Ваш код должен заполнить эти матрицы -- один столбец на патч
% то есть, 10000 столбцов. 
patches = zeros(patchsize*patchsize, numpatches);

%  ---------- YOUR CODE HERE --------------------------------------
%  Инструкции: Заполните переменную "patches" используя данные из IMAGES. 
%  
%  IMAGES это 3D массив содержаий 10 изображений
%  Например, IMAGES(:,:,6) это 512x512 массив содержащий 6-ое изображение,
%  и выможете набрать "imagesc(IMAGES(:,:,6)), colormap gray;" для того
%  чтобы его отобразить.
%  (Эти изображения выглядят немного неконтрастными из за того что они
%  прошли предварительную обработку "whitening"
%  В качастве другого примера, IMAGES(21:30,21:30,1) это патч изображения
%  соответствующий блоку пикселей находящихся в координатах
%  от (21,21) до (30,30) первого изображения.
%  [h w n] = Size(IMAGES);
h=512-patchsize-1;
w=512-patchsize-1;
n=10-1;
for i=1:numpatches
   row=uint16(rand()*h)+1;
   col=uint16(rand()*w)+1;
   img_num=uint16(rand()*n)+1;
   tmp=IMAGES(row:(row+patchsize-1),col:(col+patchsize-1),img_num)';
   patches(:,i)=reshape(tmp,patchsize*patchsize, 1);
end;
% ---------------------------------------------------------------
% Для того чтобы автоэнкодер работал хорошо необходимо нормализовать
% данные.
% В частности, так как выход сети лежит в диапазоне [0,1]
% (из-за сигмоидной функции активации), мы должны привести
% диапазон входных значений (значения яркостей пикселей) также к [0,1]
patches = normalizeData(patches);
end
% ---------------------------------------------------------------
function patches = normalizeData(patches)
% Приводим данные к диапазону [0.1, 0.9] т.к. мы использем сигмоиду в качестве 
% функции активации выходного слоя
% Центрируем выборку. 
patches = bsxfun(@minus, patches, mean(patches));
% Отсекаем по порогу +/-3 стандартных отклонения иприводим к диапазонк -1 to 1
pstd = 3 * std(patches(:));
patches = max(min(patches, pstd), -pstd) / pstd;
% приводим значения находящиеся в диапазоне [-1,1] к диапазону [0.1,0.9]
patches = (patches + 1) * 0.4 + 0.1;
end
